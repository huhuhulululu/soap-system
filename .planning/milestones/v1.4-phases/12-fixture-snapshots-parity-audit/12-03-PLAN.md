---
phase: 12-fixture-snapshots-parity-audit
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - src/generator/__fixtures__/parity-diff.test.ts
autonomous: true
requirements:
  - PAR-01

must_haves:
  truths:
    - "Same patient JSON fed through batch and compose paths produces byte-identical SOAP output"
    - "Parity is verified for multiple body parts and visit counts"
    - "Whitespace-normalized S/O/A/P content is identical across both paths"
  artifacts:
    - path: "src/generator/__fixtures__/parity-diff.test.ts"
      provides: "Parity diff tests proving batch/compose produce identical output"
      min_lines: 50
  key_links:
    - from: "src/generator/__fixtures__/parity-diff.test.ts"
      to: "src/shared/normalize-generation-context.ts"
      via: "import normalizeGenerationContext"
      pattern: "import.*normalizeGenerationContext.*from.*normalize-generation-context"
    - from: "src/generator/__fixtures__/parity-diff.test.ts"
      to: "src/generator/soap-generator.ts"
      via: "import exportTXSeriesAsText"
      pattern: "import.*exportTXSeriesAsText.*from.*soap-generator"
---

<objective>
Create parity diff tests proving that batch and compose paths produce identical SOAP output when given the same patient data through the shared normalizer.

Purpose: This is the final proof that PAR-01 is satisfied — same input, same seed, same output regardless of entry path. With both paths now using `normalizeGenerationContext()`, the test verifies the normalizer actually eliminates all divergence.

Output: Parity diff test file with green tests across multiple body parts and visit counts.
</objective>

<execution_context>
@/Users/ping/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ping/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-fixture-snapshots-parity-audit/12-RESEARCH.md
@.planning/phases/12-fixture-snapshots-parity-audit/12-02-SUMMARY.md

@src/shared/normalize-generation-context.ts
@src/generator/soap-generator.ts
@src/generator/__fixtures__/fixture-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parity diff tests for batch vs compose output</name>
  <files>
    src/generator/__fixtures__/parity-diff.test.ts
  </files>
  <action>
Create `src/generator/__fixtures__/parity-diff.test.ts`:

1. `beforeAll`: call `setWhitelist(whitelistData)` (same pattern as fixture-snapshots.test.ts)

2. Define a `normalizeSOAPText(text: string): string` helper that:
   - Normalizes `\r\n` → `\n`
   - Strips trailing whitespace per line
   - Collapses 3+ consecutive newlines to 2
   - Trims start/end
   This allows content-level comparison while ignoring formatting differences (per user decision: S/O/A/P content-level consistency, formatting differences allowed).

3. Define test cases — at least 7 (one per supported body part), each with:
   - A canonical `NormalizeInput` object with all required fields
   - A shared seed (same seed for both paths)
   - A txCount (mix of early/mid/late)

4. For each test case, in a `describe('Parity: batch vs compose', () => { ... })` block:

   **Path A (simulating batch):** Call `normalizeGenerationContext(input)` with NO explicit `localPattern`/`systemicPattern` (inference defaults — this is what batch does). Use the returned `context` + `initialState` to call `exportTXSeriesAsText()`.

   **Path B (simulating compose with inference):** Call `normalizeGenerationContext(input)` with the SAME input (also no overrides — simulating a compose user who accepts the inferred defaults). Use the returned `context` + `initialState` to call `exportTXSeriesAsText()`.

   Since both paths now go through the same normalizer with the same input, the output MUST be byte-identical. Assert:
   ```typescript
   for (let i = 0; i < batchResults.length; i++) {
     expect(normalizeSOAPText(composeResults[i].text))
       .toBe(normalizeSOAPText(batchResults[i].text))
   }
   ```

5. Add one additional test case where compose provides explicit TCM pattern overrides (different from inference). This test should show that overrides produce DIFFERENT output — proving the override mechanism works. Use `expect(...).not.toBe(...)` for at least one visit.

6. Add one test verifying that Strength/ROM values in the Objective section are identical between batch and compose for the same input (extract with a regex like `/Strength:?\s*(\S+)/` or check the full O section).

IMPORTANT: Both paths MUST use the same seed. The test proves that `normalizeGenerationContext()` is the sole source of truth and eliminates all divergence.
  </action>
  <verify>
Run `npx vitest run src/generator/__fixtures__/parity-diff.test.ts` — all tests pass green. Also run `npx vitest run src/generator/__fixtures__/` to confirm both parity and snapshot tests pass together.
  </verify>
  <done>Parity diff tests pass green. Batch and compose paths produce identical SOAP output for same patient data through the shared normalizer. Override mechanism is verified. Strength/ROM parity is confirmed.</done>
</task>

<task type="auto">
  <name>Task 2: Final regression run — all 30 snapshots + parity tests green</name>
  <files>
    src/generator/__fixtures__/parity-diff.test.ts
    src/generator/__fixtures__/fixture-snapshots.test.ts
  </files>
  <action>
Run the complete fixture test suite to confirm everything is green:

1. `npx vitest run src/generator/__fixtures__/` — all snapshot tests (30) + all parity tests pass
2. `npx tsc --noEmit` — zero type errors across the entire project
3. Verify no engine files were modified: `git diff --name-only src/generator/tx-sequence-engine.ts src/generator/soap-generator.ts` should show no changes

If any snapshot test fails, it means Plan 02's refactor introduced a regression. Debug by comparing the normalizer's output against the original `buildContext()` output for the failing fixture's input. Fix in the normalizer, NOT in the engine.

If any parity test fails, it means the normalizer still has a divergence path. Check which field differs and trace back to the normalizer's handling of that field.

After all tests pass, commit the parity test file.
  </action>
  <verify>
`npx vitest run src/generator/__fixtures__/` exits 0. `npx tsc --noEmit` exits 0. `git diff --name-only src/generator/tx-sequence-engine.ts src/generator/soap-generator.ts` shows no output.
  </verify>
  <done>All fixture snapshots (30) and parity diff tests pass green. Zero type errors. No engine files modified. Phase 12 deliverables complete.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/generator/__fixtures__/` — all tests green (30 snapshots + parity diffs)
2. `npx tsc --noEmit` — 0 errors
3. `git diff --name-only src/generator/tx-sequence-engine.ts src/generator/soap-generator.ts` — empty (no engine modifications)
4. Parity tests prove same input → same output for 7+ body parts
</verification>

<success_criteria>
- Batch and compose paths produce byte-identical (whitespace-normalized) SOAP output for same patient data
- All 30 fixture snapshots remain green through the entire phase
- Override mechanism verified (compose user selections take priority)
- Zero engine file modifications
</success_criteria>

<output>
After completion, create `.planning/phases/12-fixture-snapshots-parity-audit/12-03-SUMMARY.md`
</output>
